package it.extrared.registry.api.rest.openapi;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import io.quarkus.smallrye.openapi.OpenApiFilter;
import it.extrared.registry.jsonschema.SchemaCache;
import it.extrared.registry.utils.JsonUtils;
import jakarta.enterprise.inject.Instance;
import jakarta.enterprise.inject.spi.CDI;
import java.util.*;
import org.eclipse.microprofile.openapi.OASFactory;
import org.eclipse.microprofile.openapi.OASFilter;
import org.eclipse.microprofile.openapi.models.ExternalDocumentation;
import org.eclipse.microprofile.openapi.models.OpenAPI;
import org.eclipse.microprofile.openapi.models.PathItem;
import org.eclipse.microprofile.openapi.models.media.Schema;
import org.eclipse.microprofile.openapi.models.parameters.RequestBody;

/**
 * Edit the autogenerated openapi document to:
 * 1) Use as schema for the registry endpoint the actual JSON Schema in use.
 * 2) Use as a schema for the JSON Schema API the external definition of the JSON schema spec instead of the jackson JsoNode.
 */
@OpenApiFilter(OpenApiFilter.RunStage.RUN)
public class RegistryOpenApiFilter implements OASFilter {

    @Override
    public void filterOpenAPI(OpenAPI openAPI) {
        OASFilter.super.filterOpenAPI(openAPI);
        Instance<SchemaCache> schemaCache = CDI.current().select(SchemaCache.class);
        Map<String, Schema> schemas = new HashMap<>(openAPI.getComponents().getSchemas());
        if (schemaCache.isResolvable()) {
            // edit the registry endpoint ref and build the schema out of the actual json schema in use
            PathItem pathItem = openAPI.getPaths().getPathItem("/registry");
            RequestBody rb = pathItem.getPOST().getRequestBody();
            rb.setRef("#/components/schemas/Metadata");
            it.extrared.registry.jsonschema.Schema mySchema =
                    schemaCache.get().get().await().indefinitely();
            JsonNode jSchema = mySchema.getSchema();
            Schema actual = jsonSchemaToSchema(jSchema.get("properties"));
            schemas.put("Metadata", actual);
            Schema dppMetadata = schemas.get("DPPMetadataEntry");
            Map<String, Schema> props = new HashMap<>(dppMetadata.getProperties());
            Schema metaProp = props.get("metadata");
            metaProp.setRef("#/components/schemas/Metadata");
            dppMetadata.setProperties(props);
        }
        // edit the schema of the JSON schema API
        PathItem pathItem = openAPI.getPaths().getPathItem("/schema");
        pathItem.getPOST().getRequestBody().setRef("#/components/schemas/JsonSchema");
        pathItem = openAPI.getPaths().getPathItem("/schema/current");
        pathItem.getGET()
                .getResponses()
                .getAPIResponse("200")
                .setRef("#/components/schemas/JsonSchema");
        Schema schema = schemaForJsonSchema();
        schemas.put("JsonSchema", schema);
        // removes the jackson types
        schemas.remove("JsonNode");
        schemas.remove("JsonNodeType");
        openAPI.getComponents().setSchemas(schemas);
    }

    private Schema schemaForJsonSchema() {
        Schema schema = OASFactory.createSchema();
        schema.setDescription("A valid JSON schema definition (draft-07)");
        schema.setType(List.of(Schema.SchemaType.OBJECT));
        schema.setAdditionalPropertiesSchema(OASFactory.createSchema().booleanSchema(true));
        ExternalDocumentation externalDocumentation = OASFactory.createExternalDocumentation();
        externalDocumentation.setDescription("JSON Schema Draft 07 Meta-Schema");
        externalDocumentation.setUrl("http://json-schema.org/draft-07/schema#");
        schema.setExternalDocs(externalDocumentation);
        return schema;
    }

    private Schema jsonSchemaToSchema(JsonNode schemaProperties) {
        Schema container = OASFactory.createSchema();
        Iterator<String> fnames = schemaProperties.fieldNames();
        while (fnames.hasNext()) {
            String fName = fnames.next();
            container.addProperty(fName, nodeToSchema(schemaProperties.get(fName)));
        }
        return container;
    }

    // maps a single JsonNode property in the JSON schema to the Schema object for the OpenAPI document.
    private Schema nodeToSchema(JsonNode json) {
        Schema schema = OASFactory.createSchema();
        JsonNode type = json.get("type");
        if (JsonUtils.nodeIsNotNull(type)) schema.setType(toSchemaType(type));
        JsonNode desc = json.get("description");
        if (JsonUtils.nodeIsNotNull(desc)) schema.setDescription(desc.asText());
        JsonNode minLen = json.get("minLength");
        if (JsonUtils.nodeIsNotNull(minLen)) schema.setMinLength(minLen.asInt());
        JsonNode maxLength = json.get("maxLength");
        if (JsonUtils.nodeIsNotNull(maxLength)) schema.setMaxLength(maxLength.asInt());
        JsonNode examples = json.get("examples");
        if (JsonUtils.nodeIsNotNull(examples)) schema.setExamples(asList(examples));
        JsonNode enums = json.get("enum");
        if (JsonUtils.nodeIsNotNull(examples)) schema.setEnumeration(asList(enums));
        JsonNode items = json.get("items");
        if (JsonUtils.nodeIsNotNull(items)) schema.setItems(nodeToSchema(items));
        JsonNode minItems = json.get("minItems");
        if (JsonUtils.nodeIsNotNull(minItems)) schema.setMinItems(minItems.asInt());
        JsonNode unique = json.get("uniqueItems");
        if (JsonUtils.nodeIsNotNull(unique)) schema.setUniqueItems(unique.asBoolean());
        JsonNode maxItems = json.get("maxItems");
        if (JsonUtils.nodeIsNotNull(maxItems)) schema.setMaxItems(maxItems.asInt());
        JsonNode format = json.get("format");
        if (JsonUtils.nodeIsNotNull(format)) schema.setFormat(format.asText());
        JsonNode pattern = json.get("pattern");
        if (JsonUtils.nodeIsNotNull(pattern)) schema.setPattern(pattern.asText());
        return schema;
    }

    private List<Object> asList(JsonNode node) {
        List<Object> list = new ArrayList<>();
        if (node instanceof ArrayNode arrayNode) {
            for (JsonNode n : arrayNode) {
                list.add(n.asText());
            }
        } else if (node != null && node.isTextual()) {
            list.add(node.asText());
        }
        return list;
    }

    private List<Schema.SchemaType> toSchemaType(JsonNode node) {
        List<Schema.SchemaType> list = new ArrayList<>();
        if (node instanceof ArrayNode arrayNode) {
            for (JsonNode n : arrayNode) {
                list.add(Schema.SchemaType.valueOf(n.asText().toUpperCase()));
            }
        } else {
            list.add(Schema.SchemaType.valueOf(node.asText().toUpperCase()));
        }
        return list;
    }
}
